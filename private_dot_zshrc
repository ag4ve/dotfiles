
# trace zshrc:
# zsh -o sourcetrace

# overload alias and print where it came from
# function alias()
# { 
#     if [[ "$@" == *"grep"* ]] ; then
#         print -r - "$funcfiletrace[1]: $0 $@"
#     fi
#     builtin $0 "$@"
# }

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

source $HOME/bin/environments.sh 2>/dev/null

aws_config="~/.aws.alt/credentials"

# If we're not in tmux, get there
#if [ -z $TMUX ] ; then
#    tmux
#fi

#if [[ -n "$SSH_AUTH_SOCK" && -S "$SSH_AUTH_SOCK" ]]; then
#  echo "export SSH_AUTH_SOCK=\"$SSH_AUTH_SOCK\"" > $HOME/.ssh/agent.sh
#else
#  source $HOME/.ssh/agent.sh 2>/dev/null
#fi

## Autoloads
autoload edit-command-line

# add custom completion scripts
fpath=(~/.zsh/completion $fpath) 

# compsys initialization
autoload -U compinit
compinit

# Path to your oh-my-zsh configuration.
ZSH=$HOME/.oh-my-zsh

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
#ZSH_THEME="spaceship"

# Set to this to use case-sensitive completion
# CASE_SENSITIVE="true"
#
# Comment this out to disable weekly auto-update checks
# DISABLE_AUTO_UPDATE="true"
#
# Uncomment following line if you want to disable colors in ls
# DISABLE_LS_COLORS="true"
#
# Uncomment following line if you want to disable autosetting terminal title.
# DISABLE_AUTO_TITLE="true"
#
# Uncomment following line if you want red dots to be displayed while waiting for completion
COMPLETION_WAITING_DOTS="true"

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(
  asdf
  autojump 
  aws
  bundler 
  catimg 
  cpanm 
  dircycle 
  docker 
  encode64 
  gem 
  git 
  git-extras 
  jsontools 
  mvn 
  npm 
  node 
  pass 
  perl 
  pip 
  python 
  ruby 
  rvm 
  svn-fast-info 
  systemd 
  taskwarrior 
  tmuxinator 
  urltools 
  vi-mode 
  web-search 
  z
)

# z don't resolve symlinks
_Z_NO_RESOLVE_SYMLINKS=1

# Disable the ASCII DC3 stop flow control CTRL+S
# REMEMBER - add this to all shell configs no matter what !!!!

stty -ixon

# Go
export GOPATH="$HOME/.config/go"
#export GOROOT="$HOME/.config/go/bin"

unset path
path+=($HOME/bin)                                       # Local user bin
path+=($HOME/.local/bin)                                # Local user bin
path+=($HOME/.rvm/bin)                                  # RVM
path+=($HOME/.pyenv/bin)                                # PyEnv
path+=($HOME/.cargo/bin)                                # Cargo bins
path+=($HOME/.local/share/bob/nvim-bin)                  # BOB NEOVim version manager
#path+=($HOME/perl5/perlbrew/bin)                        # Perlbrew
#path+=(/opt/homebrew/opt/ruby/bin)                      # homebrew's ruby install
path+=($GOROOT)                                         # golang binary and dependencies
path+=($HOME/gits/bash-libs)                            # Bash libs to be sourced
path+=(/var/lib/snapd/snap/bin)                         # Snap path
#path+=($HOME/.linuxbrew/{bin,sbin})                            # Homebrew binaries
path+=(/usr/local/ftimes/bin)                           # Ftimes
path+=($HOME/.tfenv/bin)                                # tfenv
path+=($HOME/.arkade/bin)                               # arkade
path+=(/snap/bin)                                       # snap bin
path+=(/opt/android-sdk-update-manager/platform-tools)  # Android sdk
path+=(/usr/local/texlive/2015/bin/x86_64-linux)        # TexLive install dir
path+=(/etc/alternatives)                               # Debian alternatives first
path+=({/usr/local,/usr,}/{bin,sbin})                   # All normal system paths
export PATH

manpath=""
manpath+=(/usr/local/ftimes/man)
export MANPATH

export TERM=screen-256color
export TZ=America/New_York
export KEYTIMEOUT=1
export EDITOR=vim
export VISUAL=vim
export GIT_EDITOR=vim
export WORDCHARS='-' # consider --version, -h, etc one whole word
export BC_ENV_ARGS=$HOME/.bcrc
export CVS_RSH=ssh
export TMPDIR=$HOME/tmp

export PYENV_ROOT="$HOME/.pyenv"

source $ZSH/oh-my-zsh.sh

#export PAGER="batcat --language man --theme ansi"
# Make VIM man pager
# export PAGER="/bin/sh -c \"unset PAGER;col -b -x | \
#     vim -R -c 'set ft=man nomod nolist' -c 'map q :q<CR>' \
#     -c 'map <SPACE> <C-D>' -c 'map b <C-U>' \
#     -c 'nmap K :Man <C-R>=expand(\\\"<cword>\\\")<CR><CR>' -\""

#export PAGER="vim -c \"Man $1 $2\" -c 'silent only' \
#    -U NONE -u vim-man"

# Set vi-mode and create a few additional Vim-like mappings
bindkey -v
bindkey "^?" backward-delete-char
bindkey -M vicmd "^R" redo
bindkey -M vicmd "u" undo
bindkey -M vicmd "ga" what-cursor-position
bindkey -M viins '^p' history-beginning-search-backward
bindkey -M vicmd '^p' history-beginning-search-backward
bindkey -M viins '^n' history-beginning-search-forward
bindkey -M vicmd '^n' history-beginning-search-forward

# Allows editing the command line with an external editor
zle -N edit-command-line
bindkey -M vicmd "v" edit-command-line

# Homebrew
#eval "$(/opt/homebrew/bin/brew shellenv)"

# enable perlbrew
#source $HOME/perl5/perlbrew/etc/bashrc
#perlbrew use perl-5.30.0

# Enable PyEnv
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"

# enable rvm
source $HOME/.rvm/scripts/rvm 2>/dev/null

# aws completion
#source $HOME/gits/aws-cli/bin/aws_zsh_completer.sh

# gcp completion
#source /opt/homebrew/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/path.zsh.inc

# Dargs competion
if [[ -d "~/.dargs/completions/zsh" ]];then
  for f in ~/.dargs/completions/zsh/*;do source "$f";done
fi

# GPG
export GPG_TTY="$(tty)"
export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
gpgconf --launch gpg-agent

# the fuck
#eval $(thefuck --alias --enable-experimental-instant-mode)
eval $(thefuck --alias)

# proxy export
#eval $(~/bin/proxy)

# Comments on the command line
setopt interactivecomments

# Per session "up arrow" history
zle-line-init() { zle set-local-history 1 }
zle -N zle-line-init

zle-keymap-select() {
    [[ $KEYMAP = isearch ]]
    zle set-local-history $?
}
zle -N zle-keymap-select

# alt+s inserts sudo at the beginning of a command
insert_sudo () { zle beginning-of-line; zle -U "sudo " }
zle -N insert-sudo insert_sudo
bindkey "\er" insert-sudo

# make vim use or initialize a session with a new tab unless...
# alias this so that we can do \vim to get to the exe
# vimfunc () {
#     local cmd
#     local servername
#     local remote
#     local -a misc
#     local version
#     local username=$(echo $USER | tr "[:lower:]" "[:upper:]")
#     local opt_ex="^-"
# 
#     while [ $# -gt 0 ] ; do
#         case "$1" in
#             --servername)
#                 if [[ $2 =~ $opt_ex ]] ; then
#                     echo "Servername option without a parameter. Doing nothing."
#                     return
#                 else
#                     servername="$2"
#                     shift
#                 fi
#                 ;;
#             --remote*)
#                 if [ -z $remote ] ; then
#                     if [[ $2 =~ $opt_ex ]] ; then
#                         remote="$1"
#                     else
#                         remote="$1 $2"
#                         shift
#                     fi
#                 else
#                     # I'll deal with this properly if it is reasonable to take multiple --remote* things
#                     echo "Should not call two remote options at once. Doing nothing."
#                     return
#                 fi
#                 ;;
#             --version*)
#                 version="1"
#                 ;;
#             *)
#                 misc+=("$1")
#                 ;;
#         esac
#         shift
#     done
# 
#     cmd="vim -v"
# 
#     if [ ! -z $servername ] ; then
#         cmd="$cmd --servername $servername"
#     else
#         cmd="$cmd --servername $username"
#     fi
# 
#     if [ -z $misc ] && [ -z $remote ] ; then
#         # list version if we asked for that
#         if [ ! -z version ] ; then
#             cmd="$cmd --version"
#         fi       
# 
#         ${=cmd}
# 
#         return
#     fi
# 
#     if [ ! -z $remote ] ; then
#         cmd="$cmd $remote $misc"
#     else
#         cmd="$cmd --remote-tab $misc"
#     fi
# 
#     echo $cmd
#     command ${=cmd}
# 
#     return
# }
#alias vim='vimfunc'

ioline () {
    echo -n "[$@] ["
    echo -n $(eval $@)
    echo -n "]\n"
}

# Convert number to normal ip
int2ip () {
    perl -e "print join '.', unpack 'C4', pack 'N', $@"
}

# Pertinent information from whois
whoism () {
    whois "$1" | egrep '^(inetnum|netname|descr|address|CIDR|OrgName|OrgId|Address|City|StateProv|PostalCode|[Cc]ountry|inetrev|owner(id)?|responsible|nserver):'
}
compdef whoism=whois

# Reset forwarded ssh port forward connections
rst-fwd () {
    local host="$1"

    # Match 3 level names such as sink-abby-fwd
    #if [[ "$1" =~ ".*-.*-.*" ]] ; then
    #    host="${1#*-}"
    #fi

    pkill -f "ssh (-[Nf] ){2}.*$host"

    ssh -N -f "$1" > /dev/null 2>&1
}
compdef rst-fwd=ssh

# Regex grep all ASCII files in a directory
tgrep () {
    string="$1"
    local dir="$2"

    if [ -z "$dir" ] ; then
        dir="./"
    fi

    while read file ; do
        if [[ "$(file -b --mime-encoding "$file")" = *ascii* ]] ; then
            grep -HE "$string" "$file"
        fi
    done <<< "$(command find $dir -type f)"
}
compdef tgrep=egrep

# short dig
sdig () {
  dig "$@" +short
}
compdef sdig=dig

# long dig

ldig () {
  dig +trace +nocmd "$@" any +multiline +answer
}
compdef ldig=dig

iplook () {
  inip="$1"
  dig -x "$inip" +short
  geocidr --ip "$inip"
  whoism "$inip"
}

s_client () {
  command openssl s_client -connect "$1:443" -servername "$1" -showcerts -verify 10 <<<"QUIT" 2>&1
}

asn1parse () {
  command openssl asn1parse -in "$1" -dump -i
}

find () {
  command find "$PWD" $@
}

# pi numbers, truncate to last numbers
pinum () {
  local num="$1"
  local offset="$2"

  if [[ -z "$num" ]] ; then
    return
  fi
  if [[ -z "$offset" ]] ; then
    offset="0"
  fi

  python -c "\
import sys,gmpy2; \
num = int(sys.argv[1]); \
offset = int(sys.argv[2]); \
print(str(gmpy2.const_pi(1048576))[offset:num + offset]) \
" "$num" "$offset"

}

# Start tmux sessions with ssh connections
ssh_start() {

  if [[ -n "$2" && "$2" == home ]] ; then
    tmux-start -n "$1" -c sshs -p 0 -P 1 -f
  else
    tmux-start -n "$1" -c sshs -p 0 -P 1 -f -a "-ifwd"
  fi
}

# Handle quoting in rsync
#rsync() {
#    dst="$@[-1]"
#    src="$@[1,-2]"
#    print "[$src] [$dst]"
#    command rsync --progress --recursive "\"$src\" $dst"
#}

prsync() {
  : "${ruser:="$USER"}"
  command rsync -r -a --partial --info=progress2 -e "ssh -i ~/.ssh/id_rsa -o User=$ruser" $@
}
compdef prsync=rsync

ec2search() {
  in="$1"
  for profile in default prod gss; do
    AWS_SHARED_CREDENTIALS_FILE="$aws_config" AWS_PROFILE=$profile $HOME/.local/venvs/aws/bin/aws ec2 describe-instances \
      --query 'Reservations[].Instances[].[ LaunchTime,InstanceId,[Tags[?Key==`Name`].Value][0][0],State.Name,PrivateIpAddress, VirtualizationType ]' \
      --output table \
        | grep -i "$in" \
        | sort -n
  done
}

defstrace () {
  command strace -f -e open,access,connect,recvfrom,sendto,network $@
}
compdef defstrace=strace

# Run crowbar with common users
ucrowbar () {
  for user in ec2-user chef jenkins centos tomcat root ubuntu apache; do
    echo $user
    $HOME/gits/crowbar/crowbar.py -b sshkey -s "$1" -u "$user" -k ~/.ssh -o /dev/null -l /dev/null 2>&1 \
      | grep -vE ' (Crowbar v|LOG-SSH:|START|STOP|No results found...)'
  done
}

# Re-source zshrc unless $NO_AUTOSOURCE is set
resource_zshrc() {
    if [ -z NO_AUTOSOURCE ] ; then
        return
    fi

    local -a stat
    integer last_change
    zmodload -F zsh/stat b:zstat

    zstat -A stat +mtime ~/.zshrc
    last_change=$stat[1]

    if [[ -n $ZSHRC_LAST_CHANGE && last_change -gt ZSHRC_LAST_CHANGE ]]; then
        # We don't want this to occur in function scope.
        trap '. ~/.zshrc > /dev/null 2>&1' EXIT

        # Reload executable paths as path may have changed
        rehash
    fi

    typeset -ig ZSHRC_LAST_CHANGE
    ZSHRC_LAST_CHANGE=last_change
}

# Re-source .ssh/agent.sh unless $NO_AUTOSOURCE is set
#resource_sshagent() {
#    if [ -z NO_AUTOSOURCE ] ; then
#        return
#    fi
#
#    local -a stat
#    integer last_change
#    zmodload -F zsh/stat b:zstat
#
#    zstat -A stat +mtime ~/.ssh/agent.sh
#    last_change=$stat[1]
#
#    if [[ -n $SSHAGENT_LAST_CHANGE && last_change -gt SSHAGENT_LAST_CHANGE ]]; then
#        # We don't want this to occur in function scope.
#        trap '. ~/.ssh/agent.sh > /dev/null 2>&1' EXIT
#    fi
#
#    typeset -ig SSHAGENT_LAST_CHANGE
#    SSHAGENT_LAST_CHANGE=last_change
#}

# QR Code of a password
qrpass () {
  pass "$1" | qrencode -o - -t UTF8
}

qrstring () {
  echo $@ | qrencode -o - -t UTF8
}

# Rename cpanm to cpan
cpan () {
    echo "Type \\cpan to execute actual cpan command"
    cpanm $@
}
compdef cpan=cpanm

# Include a default Data::Dumper when calling perl
perlfunc () {
    command perl -MData::Dumper \
        -e '$Data::Dumper::Sortkeys= 
            sub {return [
                sort {$a <=> $b} keys %{$_[0]} 
            ]};' \
        $@
}
alias perl='perlfunc'

tgit () {
  opts="$@"
  tgit_log="$( \
#    strace -f -e open,access,connect,recvfrom,sendto,network -- \
    dtruss -f -e open,access,connect,recvfrom,sendto,network -- \
      bash -c ' set -vx ; \
        GIT_TRACE=1 \
        GIT_TRACE_PACK_ACCESS=1 \
        GIT_TRACE_PACKET=1 \
        GIT_TRACE_PERFORMANCE=1 \
        GIT_TRACE_SETUP=1 \
        GIT_SSH_COMMAND="ssh -vvvv " \
        GIT_PAGER= \
        git '$opts' \
      ' 2>&1 \
  )"
  echo "$tgit_log" | grep -vaE '^(([0-9]{2}:){2}[0-9]{2}\.[0-9]{6}|debug[0-9]:|\[pid [0-9]+\]|strace: Process [0-9]+|.* = -1 ENOENT) '
}
compdef tgit=git

tglog () {
  echo \"$tgit_log\" | grep -aE '^(([0-9]{2}:){2}[0-9]{2}\.[0-9]{6}|debug[0-9]:|\[pid [0-9]+\]|strace: Process [0-9]+|.* = -1 ENOENT) '
}

tfshow() {
  tmp="$(mktemp ./plan.XXXXXX)"
  terraform plan --out "$tmp" >/dev/null
  terraform show -json "$tmp" | jq -rSC . | bat
  rm -f "$tmp"
}

# Remove AWS box
termbox() {
  aws ec2 modify-instance-attribute --instance-id "$1" --no-disable-api-termination
  aws ec2 terminate-instances --instance-ids "$1"
}
# compdef termbox=aws

#aws() {
#  AWS_SHARED_CREDENTIALS_FILE="$aws_config" command $HOME/.local/venvs/aws/bin/aws $@
#}

compdef fwk=ssh
compdef sshs=ssh

# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"
alias ymdhms='date +%Y%m%d%H%M%S' # long date format - yyyymmddHHMMSS
alias mdyhms='date "+%m/%d/%y %H:%M:%S"' # date format - mm/dd/yy HH:MM:SS
alias refresh='exec su -p -l $USER -' # relogin
alias bundleinstall='vim +BundleInstall +qall' # install vim bundles
alias less='less -R' # display ANSI color
alias tree='tree -Chug'
alias file='file -sL'
alias cidr='geocidr --header --ip '
alias uridec="perl -MURI::Escape -nle 'print uri_unescape(\$_)'"
alias torexit='curl http://torstatus.blutmagie.de/ip_list_exit.php/Tor_ip_list_EXIT.csv'
alias dicepass="perl -MCrypt::XkcdPassword -e 'print Crypt::XkcdPassword->make_password(\$_)'"
alias rst-term="source ~/.zshrc"
#alias whatip="curl http://ifconfig.me"
alias whatip6="curl -s http://ip4only.me/api/ | cut -d',' -f2"
alias whatip4="curl -s http://ip6only.me/api/ | cut -d',' -f2"
alias whatip="whatip4;whatip6"
alias irssi="TERM=screen-256color irssi"
alias udevinfo="udevadm info"
alias torcurl="curl --socks5 127.0.0.1:9050"
alias xv="geeqie"
alias sshn="ssh -F /dev/null"
alias scpn="scp -F /dev/null"
alias gpgn="gpg --no-use-agent"
alias jq="jq --indent 4"
alias paste="curl -F 'sprunge=<-' http://sprunge.us"
#alias paste="curl http://haste.icam.uscis.dhs.gov/documents -X POST -d -"
alias rdiglist="while read ip; do dns="$(dig -x "$ip" +short)"; echo "$ip $dns"; done"
alias rmcontrol="rm ~/.ssh/control-*"
alias rekey="killall ssh-agent; ssh-add -s /usr/local/lib/tokendPKCS11.so"
#alias brew='env PATH="${PATH//$(pyenv root)\/shims:/}" brew'
alias bat="batcat --pager less"

# Change keyboard layout
#alias aoeu="setxkbmap us"
#alias asdf="setxkbmap dvorak"

alias vim="nvr --remote-tab"

# As root
#alias asdf="loadkeys /usr/share/keymaps/i386/dvorak/dvorak.kmap.gz"
#alias aoeu="loadkeys /usr/share/keymaps/i386/include/qwerty-layout.inc.gz"

# Source precmd functions
precmd() {
    resource_zshrc
    #resource_sshagent
}

# If we're still not in a tmux session, exit - close the session when we close the last tmux window
# I think this is dangerous and I should find a better way.
#if [ -z $TMUX ] ; then
#    echo "TMUX: $TMUX"
#    exit
#fi

eval "$(direnv hook zsh)"

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"


